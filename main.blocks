<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="dzI!!/ID5R]|=+lW}hrY" x="20" y="20"><statement name="HANDLER"><block type="typescript_statement" id="?4IiGqe*ATV=(tM@Z=0m"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace gdcTCS34725 {" line1="" line2="basic.forever(function () {" line3="&#9;" line4="})" line5="" line6="let TCS34725_ADDR = 0x29" line7="" line8="enum TCS34752_reg {" line9="    TCS34725_CMD_BIT        =  0x80," line10="    TCS34725_CMD_Read_Byte  =  0x00," line11="    TCS34725_CMD_Read_Word  =  0x20," line12="    TCS34725_CMD_Clear_INT  =  0x66,     // RGBC Interrupt flag clear" line13="    " line14="    TCS34725_ENABLE         =  0x00,     " line15="    TCS34725_ENABLE_AIEN    =  0x10,     // RGBC Interrupt Enable " line16="    TCS34725_ENABLE_WEN     =  0x08,     // Wait enable - Writing 1 activates the wait timer " line17="    TCS34725_ENABLE_AEN     =  0x02,     // RGBC Enable - Writing 1 actives the ADC, 0 disables it " line18="    TCS34725_ENABLE_PON     =  0x01,     // Power on - Writing 1 activates the internal oscillator, 0 disables it " line19="    " line20="    TCS34725_ATIME         =   0x01,     // Integration time " line21="    TCS34725_WTIME         =   0x03,     // Wait time (if TCS34725_ENABLE_WEN is asserted)" line22="    TCS34725_WTIME_2_4MS   =   0xFF,     // WLONG0 = 2.4ms   WLONG1 = 0.029s" line23="    TCS34725_WTIME_204MS   =   0xAB,     // WLONG0 = 204ms   WLONG1 = 2.45s " line24="    TCS34725_WTIME_614MS   =   0x00,     // WLONG0 = 614ms   WLONG1 = 7.4s  " line25="    " line26="    TCS34725_AILTL         =   0x04,     // Clear channel lower interrupt threshold" line27="    TCS34725_AILTH         =   0x05," line28="    TCS34725_AIHTL         =   0x06,     // Clear channel upper interrupt threshold" line29="    TCS34725_AIHTH         =   0x07," line30="    " line31="    TCS34725_PERS          =   0x0C,     // Persistence register - basic SW filtering mechanism for interrupts */" line32="    TCS34725_PERS_NONE     =   0x00,     // Every RGBC cycle generates an interrupt                                */" line33="    TCS34725_PERS_1_CYCLE  =   0x01,     // 1 clean channel value outside threshold range generates an interrupt   */" line34="    TCS34725_PERS_2_CYCLE  =   0x02,     // 2 clean channel values outside threshold range generates an interrupt  */" line35="    TCS34725_PERS_3_CYCLE  =   0x03,     // 3 clean channel values outside threshold range generates an interrupt  */" line36="    TCS34725_PERS_5_CYCLE  =   0x04,     // 5 clean channel values outside threshold range generates an interrupt  */" line37="    TCS34725_PERS_10_CYCLE =   0x05,     // 10 clean channel values outside threshold range generates an interrupt */" line38="    TCS34725_PERS_15_CYCLE =   0x06,     // 15 clean channel values outside threshold range generates an interrupt */" line39="    TCS34725_PERS_20_CYCLE =   0x07,     // 20 clean channel values outside threshold range generates an interrupt */" line40="    TCS34725_PERS_25_CYCLE =   0x08,     // 25 clean channel values outside threshold range generates an interrupt */" line41="    TCS34725_PERS_30_CYCLE =   0x09,     // 30 clean channel values outside threshold range generates an interrupt */" line42="    TCS34725_PERS_35_CYCLE =   0x0a,     // 35 clean channel values outside threshold range generates an interrupt */" line43="    TCS34725_PERS_40_CYCLE =   0x0b,     // 40 clean channel values outside threshold range generates an interrupt */" line44="    TCS34725_PERS_45_CYCLE =   0x0c,     // 45 clean channel values outside threshold range generates an interrupt */" line45="    TCS34725_PERS_50_CYCLE =   0x0d,     // 50 clean channel values outside threshold range generates an interrupt */" line46="    TCS34725_PERS_55_CYCLE =   0x0e,     // 55 clean channel values outside threshold range generates an interrupt */" line47="    TCS34725_PERS_60_CYCLE =   0x0f,     // 60 clean channel values outside threshold range generates an interrupt */" line48="    " line49="    TCS34725_CONFIG         =  0x0D," line50="    TCS34725_CONFIG_WLONG   =  0x02,     // Choose between short and long (12x) wait times via TCS34725_WTIME */" line51="    " line52="    TCS34725_CONTROL       =   0x0F,     // Set the gain level for the sensor */" line53="    TCS34725_ID            =   0x12,     // 0x44 = TCS34721/TCS34725, 0x4D = TCS34723/TCS34727 */" line54="    " line55="    TCS34725_STATUS        =   0x13," line56="    TCS34725_STATUS_AINT   =   0x10,     // RGBC Clean channel interrupt */" line57="    TCS34725_STATUS_AVALID =   0x01,     // Indicates that the RGBC channels have completed an integration cycle */" line58="    " line59="    TCS34725_CDATAL        =   0x14,     // Clear channel data */" line60="    TCS34725_CDATAH        =   0x15," line61="    TCS34725_RDATAL        =   0x16,     // Red channel data */" line62="    TCS34725_RDATAH        =   0x17," line63="    TCS34725_GDATAL        =   0x18,     // Green channel data */" line64="    TCS34725_GDATAH        =   0x19," line65="    TCS34725_BDATAL        =   0x1A,     // Blue channel data */" line66="    TCS34725_BDATAH        =   0x1B" line67="}" line68="" line69="/**" line70="* Integration Time" line71="**/" line72="export enum TCS34725IntegrationTime {" line73="    TCS34725_INTEGRATIONTIME_2_4MS = 0xFF,   /**&lt;  2.4ms - 1 cycle    - Max Count: 1024  */" line74="    TCS34725_INTEGRATIONTIME_24MS = 0xF6,   /**&lt;  24ms  - 10 cycles  - Max Count: 10240 */" line75="    TCS34725_INTEGRATIONTIME_50MS = 0xEB,   /**&lt;  50ms  - 20 cycles  - Max Count: 20480 */" line76="    TCS34725_INTEGRATIONTIME_101MS = 0xD5,   /**&lt;  101ms - 42 cycles  - Max Count: 43008 */" line77="    TCS34725_INTEGRATIONTIME_154MS = 0xC0,   /**&lt;  154ms - 64 cycles  - Max Count: 65535 */" line78="    TCS34725_INTEGRATIONTIME_700MS = 0x00    /**&lt;  700ms - 256 cycles - Max Count: 65535 */" line79="}" line80="" line81="let IntegrationTime = 0" line82="" line83="/**" line84="* Gain" line85="**/" line86="export enum TCS34725Gain {" line87="        TCS34725_GAIN_1X = 0x00,   /**&lt;  No gain  */" line88="        TCS34725_GAIN_4X = 0x01,   /**&lt;  4x gain  */" line89="        TCS34725_GAIN_16X = 0x02,   /**&lt;  16x gain */" line90="        TCS34725_GAIN_60X = 0x03    /**&lt;  60x gain */" line91="}" line92="" line93="let Gain = 0" line94="    " line95="let tcs34725RGB = {  " line96="    clear: 0,     " line97="    red: 0," line98="    green: 0," line99="    blue: 0" line100="};" line101="" line102="/**" line103=" * set TCS34725 reg" line104=" */" line105="function setReg(reg: number, dat: number): void {" line106="    let buf = pins.createBuffer(2);" line107="    buf[0] = reg | TCS34752_reg.TCS34725_CMD_BIT;" line108="    buf[1] = dat;" line109="    pins.i2cWriteBuffer(TCS34725_ADDR, buf);" line110="}" line111="" line112="/**" line113=" * get ds1307's reg" line114=" */" line115="function getReg(reg: number): number {" line116="    pins.i2cWriteNumber(TCS34725_ADDR, reg | TCS34752_reg.TCS34725_CMD_BIT, NumberFormat.UInt8BE);" line117="    return pins.i2cReadNumber(TCS34725_ADDR, NumberFormat.UInt8BE);" line118="}" line119="" line120="/**" line121="  * get ds1307's reg Word" line122="  */" line123="function getWord(reg: number): number {" line124="    let buf2 = pins.createBuffer(2);" line125="    let val = 0;" line126="" line127="    pins.i2cWriteNumber(TCS34725_ADDR, reg | TCS34752_reg.TCS34725_CMD_BIT, NumberFormat.UInt8BE);" line128="    buf2 = pins.i2cReadBuffer(TCS34725_ADDR, 2)" line129="    val = buf2[1]&lt;&lt;8 | buf2[0];" line130="    return val" line131="}" line132="" line133="//% block=&quot;tcs34725 enable&quot;" line134="export function tcs34725_enable() {" line135="    setReg(TCS34752_reg.TCS34725_ENABLE, TCS34752_reg.TCS34725_ENABLE_PON);" line136="    control.waitMicros(3000)" line137="    setReg(TCS34752_reg.TCS34725_ENABLE, TCS34752_reg.TCS34725_ENABLE_PON | TCS34752_reg.TCS34725_ENABLE_AEN);" line138="    control.waitMicros(3000)" line139="}" line140="" line141="//% block=&quot;tcs34725 disable&quot;" line142="export function tcs34725_disable() {" line143="    /* Turn the device off to save power */" line144="    let reg = 0" line145="    reg = getReg(TCS34752_reg.TCS34725_ENABLE);" line146="    setReg(TCS34752_reg.TCS34725_ENABLE, reg &amp; ~(TCS34752_reg.TCS34725_ENABLE_PON | TCS34752_reg.TCS34725_ENABLE_AEN));" line147="}" line148="" line149="//% block=&quot;tcs34725 set integration time $value&quot;" line150="export function tcs34725_set_integration_time(time: gdcTCS34725.TCS34725IntegrationTime)" line151="{" line152="    /* Update the timing register */" line153="    setReg(TCS34752_reg.TCS34725_ATIME, time);" line154="    IntegrationTime = time;" line155="}" line156="" line157="//% block=&quot;tcs34725 set gain $value&quot;" line158="export function tcs34725_set_gain(gain: gdcTCS34725.TCS34725Gain)" line159="{" line160="    setReg(TCS34752_reg.TCS34725_CONTROL, gain);" line161="    Gain = gain;" line162="}" line163="" line164="" line165="//% block=&quot;tcs34725 get raw RGB&quot;" line166="export function tcs34725_get_rgb_data()" line167="{" line168="    let rgb = tcs34725RGB" line169="    let C = getWord(TCS34752_reg.TCS34725_CDATAL);" line170="    let R = getWord(TCS34752_reg.TCS34725_RDATAL);" line171="    let G = getWord(TCS34752_reg.TCS34725_GDATAL);" line172="    let B = getWord(TCS34752_reg.TCS34725_BDATAL);" line173="" line174="    if(C == 0) {" line175="        rgb.clear = 0;" line176="        rgb.red = 0;" line177="        rgb.green = 0;" line178="        rgb.blue = 0;" line179="    }" line180="    else {" line181="        rgb.clear = C;" line182="        rgb.red = R;" line183="        rgb.green = G;" line184="        rgb.blue = B;" line185="    }" line186="    return rgb;" line187="}" line188="" line189="//% block=&quot;tcs34725 get RGB&quot;" line190="export function tcs34725_get_rgb() {" line191="    let rgb2 = tcs34725_get_rgb_data();" line192="" line193="    let y = rgb2.red*1.0;" line194="    y = ((y/rgb2.clear)*256.0)/255.0" line195="    y = Math.pow(y, 2.5)*255.0" line196="    rgb2.red = y" line197="" line198="    y = rgb2.green * 1.0;" line199="    y = ((y / rgb2.clear) * 256.0) / 255.0" line200="    y = Math.pow(y, 2.5) * 255.0" line201="    rgb2.green = y" line202="" line203="    y = rgb2.blue * 1.0;" line204="    y = ((y / rgb2.clear) * 256.0) / 255.0" line205="    y = Math.pow(y, 2.5) * 255.0" line206="    rgb2.blue = y" line207="" line208="    return rgb2;" line209="}" line210="" line211="//% block=&quot;tcs34725 init&quot;" line212="export function tcs34725_init()" line213="{" line214="    let ID = 0;" line215="    ID = getReg(TCS34752_reg.TCS34725_ID);" line216="    if (ID != 0x44 &amp;&amp; ID != 0x4D) {" line217="        return 1;" line218="    }" line219="" line220="    //Set the integration time and gain" line221="    tcs34725_set_integration_time(TCS34725IntegrationTime.TCS34725_INTEGRATIONTIME_154MS);" line222="    tcs34725_set_gain(TCS34725Gain.TCS34725_GAIN_60X);" line223="    tcs34725_enable();" line224="    " line225="    return 0;" line226="}" line227="}" numlines="228"></mutation></block></statement></block></xml>